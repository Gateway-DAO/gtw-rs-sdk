use serde::{Deserialize, Serialize};

# [doc = r" Error types."] pub mod error { # [doc = r" Error from a TryFrom or FromStr implementation."] pub struct ConversionError (std :: borrow :: Cow < 'static , str >) ; impl std :: error :: Error for ConversionError { } impl std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> Result < () , std :: fmt :: Error > { std :: fmt :: Display :: fmt (& self . 0 , f) } } impl std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> Result < () , std :: fmt :: Error > { std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "HelperLinks"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"first\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"last\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"next\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"previous\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct HelperLinks { # [serde (default , skip_serializing_if = "Option::is_none")] pub first : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub last : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub next : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub previous : Option < String > , } impl From < & HelperLinks > for HelperLinks { fn from (value : & HelperLinks) -> Self { value . clone () } } # [doc = "HelperMeta"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"current_page\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"items_per_page\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"total_items\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"total_pages\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct HelperMeta { # [serde (default , skip_serializing_if = "Option::is_none")] pub current_page : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub items_per_page : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub total_items : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub total_pages : Option < i64 > , } impl From < & HelperMeta > for HelperMeta { fn from (value : & HelperMeta) -> Self { value . clone () } } # [doc = "HelperPaginatedResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"data\": {},"] # [doc = "    \"links\": {"] # [doc = "      \"$ref\": \"#/definitions/helper.Links\""] # [doc = "    },"] # [doc = "    \"meta\": {"] # [doc = "      \"$ref\": \"#/definitions/helper.Meta\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct HelperPaginatedResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub data : Option < serde_json :: Value > , # [serde (default , skip_serializing_if = "Option::is_none")] pub links : Option < HelperLinks > , # [serde (default , skip_serializing_if = "Option::is_none")] pub meta : Option < HelperMeta > , } impl From < & HelperPaginatedResponse > for HelperPaginatedResponse { fn from (value : & HelperPaginatedResponse) -> Self { value . clone () } } # [doc = "ModelAccessLevel"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Read\","] # [doc = "    \"Write\""] # [doc = "  ],"] # [doc = "  \"x-enum-varnames\": ["] # [doc = "    \"Read\","] # [doc = "    \"Write\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Copy , Debug , Deserialize , Eq , Hash , Ord , PartialEq , PartialOrd , Serialize)] pub enum ModelAccessLevel { Read , Write , } impl From < & ModelAccessLevel > for ModelAccessLevel { fn from (value : & ModelAccessLevel) -> Self { value . clone () } } impl ToString for ModelAccessLevel { fn to_string (& self) -> String { match * self { Self :: Read => "Read" . to_string () , Self :: Write => "Write" . to_string () , } } } impl std :: str :: FromStr for ModelAccessLevel { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "Read" => Ok (Self :: Read) , "Write" => Ok (Self :: Write) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for ModelAccessLevel { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for ModelAccessLevel { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for ModelAccessLevel { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "ModelAccountCreateRequest"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\","] # [doc = "    \"signature\","] # [doc = "    \"username\","] # [doc = "    \"wallet_address\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"username\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"wallet_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelAccountCreateRequest { pub message : String , pub signature : String , pub username : String , pub wallet_address : String , } impl From < & ModelAccountCreateRequest > for ModelAccountCreateRequest { fn from (value : & ModelAccountCreateRequest) -> Self { value . clone () } } # [doc = "ModelAccountLedgerAddRequest"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"amount\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"amount\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelAccountLedgerAddRequest { pub amount : f64 , } impl From < & ModelAccountLedgerAddRequest > for ModelAccountLedgerAddRequest { fn from (value : & ModelAccountLedgerAddRequest) -> Self { value . clone () } } # [doc = "ModelAccountLedgerCreateResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"account_id\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"amount\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"balance\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"createdAt\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"transaction_type\": {"] # [doc = "      \"$ref\": \"#/definitions/model.TransactionType\""] # [doc = "    },"] # [doc = "    \"updatedAt\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelAccountLedgerCreateResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub account_id : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub amount : Option < f64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub balance : Option < f64 > , # [serde (rename = "createdAt" , default , skip_serializing_if = "Option::is_none")] pub created_at : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub id : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub transaction_type : Option < ModelTransactionType > , # [serde (rename = "updatedAt" , default , skip_serializing_if = "Option::is_none")] pub updated_at : Option < String > , } impl From < & ModelAccountLedgerCreateResponse > for ModelAccountLedgerCreateResponse { fn from (value : & ModelAccountLedgerCreateResponse) -> Self { value . clone () } } # [doc = "ModelAuthRequest"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\","] # [doc = "    \"signature\","] # [doc = "    \"wallet_address\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"wallet_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelAuthRequest { pub message : String , pub signature : String , pub wallet_address : String , } impl From < & ModelAuthRequest > for ModelAuthRequest { fn from (value : & ModelAuthRequest) -> Self { value . clone () } } # [doc = "ModelCreateDataAssetRequest"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"acl\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"$ref\": \"#/definitions/model.RoleRequest\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"claim\": {"] # [doc = "      \"type\": \"object\""] # [doc = "    },"] # [doc = "    \"data_model_id\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"expiration_date\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"tags\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelCreateDataAssetRequest { # [serde (default , skip_serializing_if = "Vec::is_empty")] pub acl : Vec < ModelRoleRequest > , # [serde (default , skip_serializing_if = "serde_json::Map::is_empty")] pub claim : serde_json :: Map < String , serde_json :: Value > , # [serde (default , skip_serializing_if = "Option::is_none")] pub data_model_id : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub expiration_date : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub name : Option < String > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub tags : Vec < String > , } impl From < & ModelCreateDataAssetRequest > for ModelCreateDataAssetRequest { fn from (value : & ModelCreateDataAssetRequest) -> Self { value . clone () } } # [doc = "ModelDataAssetIdRequestAndResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelDataAssetIdRequestAndResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub id : Option < i64 > , } impl From < & ModelDataAssetIdRequestAndResponse > for ModelDataAssetIdRequestAndResponse { fn from (value : & ModelDataAssetIdRequestAndResponse) -> Self { value . clone () } } # [doc = "ModelDataModel"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"created_by\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"deleted_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"description\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"schema\": {"] # [doc = "      \"type\": \"object\""] # [doc = "    },"] # [doc = "    \"tags\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"title\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"updated_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelDataModel { # [serde (default , skip_serializing_if = "Option::is_none")] pub created_at : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub created_by : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub deleted_at : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub description : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub id : Option < i64 > , # [serde (default , skip_serializing_if = "serde_json::Map::is_empty")] pub schema : serde_json :: Map < String , serde_json :: Value > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub tags : Vec < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub title : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub updated_at : Option < String > , } impl From < & ModelDataModel > for ModelDataModel { fn from (value : & ModelDataModel) -> Self { value . clone () } } # [doc = "ModelMessageResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelMessageResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , } impl From < & ModelMessageResponse > for ModelMessageResponse { fn from (value : & ModelMessageResponse) -> Self { value . clone () } } # [doc = "ModelMyAccountResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"did\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"profile_picture\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"updated_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"username\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"wallet_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelMyAccountResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub created_at : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub did : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_picture : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub updated_at : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub username : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub wallet_address : Option < String > , } impl From < & ModelMyAccountResponse > for ModelMyAccountResponse { fn from (value : & ModelMyAccountResponse) -> Self { value . clone () } } # [doc = "ModelPublicDataAsset"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"data_model_id\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"did\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"expiration_date\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"fid\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"roles\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"$ref\": \"#/definitions/model.PublicRole\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"size\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"tags\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"transaction_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"type\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"updated_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelPublicDataAsset { # [serde (default , skip_serializing_if = "Option::is_none")] pub created_at : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub data_model_id : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub did : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub expiration_date : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub fid : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub name : Option < String > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub roles : Vec < ModelPublicRole > , # [serde (default , skip_serializing_if = "Option::is_none")] pub size : Option < i64 > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub tags : Vec < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub transaction_id : Option < String > , # [serde (rename = "type" , default , skip_serializing_if = "Option::is_none")] pub type_ : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub updated_at : Option < String > , } impl From < & ModelPublicDataAsset > for ModelPublicDataAsset { fn from (value : & ModelPublicDataAsset) -> Self { value . clone () } } # [doc = "ModelPublicRole"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"data_asset_id\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"role\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"updated_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"wallet_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelPublicRole { # [serde (default , skip_serializing_if = "Option::is_none")] pub created_at : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub data_asset_id : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub role : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub updated_at : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub wallet_address : Option < String > , } impl From < & ModelPublicRole > for ModelPublicRole { fn from (value : & ModelPublicRole) -> Self { value . clone () } } # [doc = "ModelRoleRequest"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"role\": {"] # [doc = "      \"$ref\": \"#/definitions/model.AccessLevel\""] # [doc = "    },"] # [doc = "    \"wallet\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelRoleRequest { # [serde (default , skip_serializing_if = "Option::is_none")] pub role : Option < ModelAccessLevel > , # [serde (default , skip_serializing_if = "Option::is_none")] pub wallet : Option < String > , } impl From < & ModelRoleRequest > for ModelRoleRequest { fn from (value : & ModelRoleRequest) -> Self { value . clone () } } # [doc = "ModelTokenResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"token\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ModelTokenResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub token : Option < String > , } impl From < & ModelTokenResponse > for ModelTokenResponse { fn from (value : & ModelTokenResponse) -> Self { value . clone () } } # [doc = "ModelTransactionType"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"deposit\","] # [doc = "    \"withdrawal\","] # [doc = "    \"payment\","] # [doc = "    \"fee_payment\""] # [doc = "  ],"] # [doc = "  \"x-enum-varnames\": ["] # [doc = "    \"TransactionTypeDeposit\","] # [doc = "    \"TransactionTypeWithdrawal\","] # [doc = "    \"TransactionTypePayment\","] # [doc = "    \"TransactionTypeFeePayment\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Copy , Debug , Deserialize , Eq , Hash , Ord , PartialEq , PartialOrd , Serialize)] pub enum ModelTransactionType { # [serde (rename = "deposit")] Deposit , # [serde (rename = "withdrawal")] Withdrawal , # [serde (rename = "payment")] Payment , # [serde (rename = "fee_payment")] FeePayment , } impl From < & ModelTransactionType > for ModelTransactionType { fn from (value : & ModelTransactionType) -> Self { value . clone () } } impl ToString for ModelTransactionType { fn to_string (& self) -> String { match * self { Self :: Deposit => "deposit" . to_string () , Self :: Withdrawal => "withdrawal" . to_string () , Self :: Payment => "payment" . to_string () , Self :: FeePayment => "fee_payment" . to_string () , } } } impl std :: str :: FromStr for ModelTransactionType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "deposit" => Ok (Self :: Deposit) , "withdrawal" => Ok (Self :: Withdrawal) , "payment" => Ok (Self :: Payment) , "fee_payment" => Ok (Self :: FeePayment) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for ModelTransactionType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for ModelTransactionType { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for ModelTransactionType { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "ResponsesEntityRemovedResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (Clone , Debug , Deserialize , Serialize)] pub struct ResponsesEntityRemovedResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , } impl From < & ResponsesEntityRemovedResponse > for ResponsesEntityRemovedResponse { fn from (value : & ResponsesEntityRemovedResponse) -> Self { value . clone () } }